name: Security Gateway

on:
  workflow_run:
    workflows:
      - "Node CI"                     # якорь
    types: [completed]

concurrency:
  group: security-gateway-${{ github.event.workflow_run.head_sha }}
  cancel-in-progress: true

permissions:
  actions: read
  contents: read
  checks: read
  pull-requests: write

jobs:
  gate:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.name == 'Node CI' }}
    runs-on: ubuntu-latest
    steps:
      - name: Wait & evaluate all checks for this commit
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const sha   = context.payload.workflow_run.head_sha;
            const runId = context.payload.workflow_run.id;

            const required = [
              "SAST - CodeQL",
              "SAST - Semgrep",
              "Lint - ESLint",
              "Dependency Audit",
              "Secrets Scan - Gitleaks",
              "DAST - OWASP ZAP Baseline",
              "Lint - GitHub Actions",
              "CI - Build & Test",
              "Node CI"
            ];

            // 1) ГАРАНТИЯ: реагируем только на САМЫЙ СВЕЖИЙ Node CI по этому SHA
            const { data: allRuns } = await github.rest.actions.listWorkflowRunsForRepo({
              owner, repo, per_page: 100, head_sha: sha, status: 'completed'
            });
            const nodeCiRuns = allRuns.workflow_runs.filter(r => r.name === 'Node CI');
            if (!nodeCiRuns.length) {
              core.setFailed('No Node CI runs found for this commit');
              return;
            }
            const latestNodeCi = nodeCiRuns[0]; // API возвращает уже отсортированным по дате
            if (latestNodeCi.id !== runId) {
              core.notice(`Skip: this event is not the latest Node CI (event=${runId}, latest=${latestNodeCi.id}).`);
              return; // выходим тихо, ждём событие от самого свежего прогона
            }

            // 2) ЖДЕМ, пока ВСЕ required перейдут в completed для этого SHA
            const timeoutMs  = 15 * 60 * 1000;
            const intervalMs = 20 * 1000;
            const deadline   = Date.now() + timeoutMs;

            async function getLatestCompletedMap() {
              const { data } = await github.rest.actions.listWorkflowRunsForRepo({
                owner, repo, per_page: 100, head_sha: sha, status: 'completed'
              });
              const map = {};
              for (const r of data.workflow_runs) {
                if (!required.includes(r.name)) continue;
                if (!map[r.name]) map[r.name] = r.conclusion; // самый свежий
              }
              return map;
            }

            while (true) {
              const latest = await getLatestCompletedMap();
              const missing = required.filter(n => latest[n] === undefined);
              if (missing.length === 0) {
                // 3) ОЦЕНКА
                const failed = Object.entries(latest)
                                     .filter(([_, c]) => c !== 'success')
                                     .map(([n, c]) => `${n}=${c}`);
                if (failed.length) {
                  core.setFailed(`Failed checks: ${failed.join(', ')}`);
                } else {
                  core.info(`Security gate passed ✅ for ${sha.substring(0,7)}`);
                }
                return;
              }
              if (Date.now() > deadline) {
                core.setFailed(`Timeout waiting for: ${missing.join(', ')}`);
                return;
              }
              core.info(`Waiting for: ${missing.join(', ')} ...`);
              await new Promise(r => setTimeout(r, intervalMs));
            }
